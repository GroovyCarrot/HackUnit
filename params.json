{
  "name": "Hackunit",
  "tagline": "xUnit testing framework written in hacklang",
  "body": "HackUnit\r\n========\r\n\r\nTesting framework written in and for [Hack.](http://hacklang.org)\r\n\r\n[![Gitter](https://badges.gitter.im/HackPack/HackUnit.svg)](https://gitter.im/HackPack/HackUnit?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\r\n\r\n### But Why?!\r\nThere are already many testing frameworks available, such as [PHPUnit](https://phpunit.de/) and [behat.](http://behat.org)  Why should you use this one?\r\n\r\n*Because you like Hack specific features!*\r\n\r\nWith HackUnit, you can easily run your tests using cooperative async using the built in `async` keyword.\r\n\r\nWith HackUnit, you indicate test methods using [annotations.](http://docs.hhvm.com/manual/en/hack.attributes.php)\r\n\r\nThe original goal of HackUnit was to write a testing framework using Hack's strict mode. The project will stay consistent with this goal as more features are added.\r\n\r\nInstall\r\n-------\r\n\r\nInstall HackUnit using [Composer](https://getcomposer.org):\r\n\r\n```bash\r\ncomposer require --dev hackpack/hackunit\r\n```\r\n\r\nUsage\r\n-----\r\n\r\nHackUnit can be run from the command line using the included executable script `bin/hackunit`. By default, this will be symlinked in your `vendor/bin` directory.\r\n\r\nThus, the most common way to invoke HackUnit is:\r\n```bash\r\nvendor/bin/hackunit path1 [path2] ...\r\n```\r\nwhere `path1`, `path2`, etc... are each base paths/files to scan for test suites.  If any specified path is a directory, the directory will be recursively scanned.\r\n\r\nSome command line options exist to alter the behavior of HackUnit:\r\n\r\n* --exclude=\"path/to/exclude\" : Do not scan the file or any file under the path provided.  This option may be given multiple times to exclude multiple paths/files.\r\n\r\nTest Suites\r\n-----------\r\nTo define a test suite, create a class and [annotate](http://docs.hhvm.com/manual/en/hack.attributes.php) the appropriate methods.\r\n\r\nYou may inspect HackUnit’s test files for concrete examples.\r\n\r\n### Tests\r\n\r\nIndividual test methods are defined using the\r\n`<<Test>>` [attribute](http://docs.hhvm.com/manual/en/hack.attributes.php).\r\nExecution order of the tests is not guaranteed.\r\n\r\nEach test method MUST accept exactly 1 parameter, with the type hint of `HackPack\\HackUnit\\Contract\\Assert`.\r\nIf you mark a method as a test and the signature does not match, the test will not be run.\r\n\r\nTest methods may be instance methods, or they may be class (static) methods.\r\n\r\n```php\r\nnamespace My\\Namespace\\Test;\r\n\r\nuse HackPack\\HackUnit\\Contract\\Assert;\r\n\r\nclass MySuite\r\n{\r\n    <<Test>>\r\n    public function testSomething(Assert $assert) : void\r\n    {\r\n      // Do some testing here!\r\n      $assert->int(2)->not()->eq(3);\r\n      $assert\r\n          ->whenCalled(() ==> {throw new \\Exception(‘bad error)})\r\n          ->willThrowClassWithMessage(\\Exception::class, ‘bad error’)\r\n          ;\r\n    }\r\n}\r\n```\r\n\r\n### Async\r\n\r\nRunning your tests async is as easy as adding the async keyword to your test method.\r\n\r\n```php\r\nnamespace My\\Namespace\\Test;\r\n\r\nuse HackPack\\HackUnit\\Contract\\Assert;\r\n\r\nclass MyAsyncSuite\r\n{\r\n    <<Test>>\r\n    public async function testSomething(Assert $assert) : Awaitable<void>\r\n    {\r\n        // Make some async DB calls here as part of your test!\r\n        $user = await get_user();\r\n\r\n        // Or maybe an async curl call\r\n        $result = await get_external_user($user->id, 'api password');\r\n\r\n        $assert->string($result['user_name'])->is('expected username');\r\n    }\r\n}\r\n```\r\n\r\nAll such `async` tests are run using cooperative multitasking (see the [async documentation](http://docs.hhvm.com/hack/async/introduction)),\r\nallowing your entire test suite to run faster if your tests perform real I/O operations (DB calls, network calls, etc...).\r\n\r\n### Setup\r\n\r\nYou may have HackUnit run some methods before each individual test method is run and/or before any test method is\r\nrun for the suite.  To do so, mark the appropriate method with the\r\n`<<Setup>>` [attribute](http://docs.hhvm.com/manual/en/hack.attributes.php).\r\nMultiple setup methods may be declared, but the execution order is not guaranteed.\r\n\r\nEach setup method (both suite and test) MUST require exactly 0 parameters.\r\nIf you mark a method as setup and it requires a parameter, it will not be executed and a parse error will be shown in the report.\r\n\r\n```php\r\nclass MySuite\r\n{\r\n    <<Setup(‘suite’)>>\r\n    public function setUpSuite() : void\r\n    {\r\n      // Suite level Setup methods must be class (static) methods\r\n      // Perform tasks before any tests in this suite are run\r\n    }\r\n\r\n    <<Setup(‘test’)>>\r\n    public function setUpTest() : void\r\n    {\r\n      // Perform tasks just before each test in this suite is run\r\n    }\r\n\r\n    <<Setup>>\r\n    public function setUpTestAgain() : void\r\n    {\r\n      // Multiple set up methods may be defined\r\n      // If there are no parameters to the setup attribute, the method is treated like a test setup\r\n    }\r\n}\r\n```\r\n\r\nSuite setup methods are run once, before any of the test methods in the class are run.\r\n\r\nTest setup methods are run just before each test method is run (and thus are potentially run multiple times).\r\n\r\n### Teardown\r\nYou may have HackUnit run some methods after each individual test method is run and/or after all test methods are\r\nrun for the suite.  To do so, mark the appropriate method with the\r\n`<<TearDown>>` [attribute](http://docs.hhvm.com/manual/en/hack.attributes.php).\r\nMultiple teardown methods may be declared, but the execution order is not guaranteed.\r\n\r\nEach teardown method (both suite and test) MUST require exactly 0 parameters.\r\nIf you mark a method as teardown and it requires a parameter, it will not be executed and a parse error will be shown in the report.\r\n\r\n```php\r\nclass MySuite\r\n{\r\n    <<TearDown(‘suite’)>>\r\n    public static function cleanUpAfterSuite() : void\r\n    {\r\n      // Suite level TearDown methods must be class (static) methods\r\n      // Perform tasks after all tests in this suite are run\r\n    }\r\n\r\n    <<TearDown(‘test’)>>\r\n    public function cleanUpAfterTest() : void\r\n    {\r\n      // Perform tasks just after each test in this suite is run\r\n    }\r\n\r\n    <<TearDown>>\r\n    public function cleanUpMoarStuff() : void\r\n    {\r\n      // This is also a ‘test’ teardown method\r\n    }\r\n}\r\n```\r\n\r\nSuite tear down methods are run once, after all of the test methods in the class are run.\r\n\r\nTest tear down methods are run just after each test method is run (and thus are potentially run multiple times).\r\n\r\n### Suite Providers\r\nYour test suite may require parameters to be passed to the constructor.  To tell HackUnit how to construct your test suite, you must define at least one Suite Provider.\r\nA Suite Provider is marked with the `<<SuiteProvider>>` attribute.\r\n\r\nYou may define multiple Suite Providers for a single test suite.  To do so, you must label each one\r\nby passing in one string parameter to the attribute (i.e., `<<SuiteProvider('name of provider')>>`).\r\nThere are no restrictions on the name of a provider except that each provider name must be unique.\r\n\r\nTo use a particular Suite Provider for a particular test, you must pass the name of the Suite Provider to the Test attribute.\r\n\r\n```\r\nclass SuiteWithProviders\r\n{\r\n    <<SuiteProvider('One')>>\r\n    public static function() : this\r\n    {\r\n        $someDependency = new TestDoubleOne();\r\n        return new static($someDependency);\r\n    }\r\n\r\n    <<SuiteProvider('Two')>>\r\n    public static function() : this\r\n    {\r\n        $someDependency = new TestDoubleTwo();\r\n        return new static($someDependency);\r\n    }\r\n\r\n    <<Test('One')>>\r\n    public function testOne(Assert $assert) : void\r\n    {\r\n        // Do some assertions using TestDoubleOne\r\n    }\r\n\r\n    <<Test('Two')>>\r\n    public function testTwo(Assert $assert) : void\r\n    {\r\n        // Do some assertions using TestDoubleTwo\r\n    }\r\n}\r\n```\r\n\r\nAssertions\r\n----------\r\n\r\nAll test methods must accept exactly one parameter of type `HackPack\\HackUnit\\Contract\\Assert` which should be used to make testable assertions.\r\nThis object is used to build assertions that will be checked and reported by HackUnit.\r\n\r\nIn all examples below, `$assert` contains an instance of `HackPack\\HackUnit\\Contract\\Assert`.\r\n\r\n### Bool Assertions\r\n\r\nTo make assertions about `bool` type variables, call `$assert->bool($myBool)->is($expected)`.\r\n\r\n### Numeric Assertions\r\n\r\nTo make assertions about `int` and `float` type variables, call `$assert->int($myInt)` and `$assert->float($myFloat)` respectively.\r\nThe resulting object contains the following methods to actually perform the appropriate assertion.\r\n\r\n* `$assert->int($myInt)->eq($expected);` : Assert that `$myInt` is identical to `$expected`\r\n* `$assert->int($myInt)->gt($expected);` : Assert that `$myInt` is greater than `$expected`\r\n* `$assert->int($myInt)->lt($expected);` : Assert that `$myInt` is less than `$expected`\r\n* `$assert->int($myInt)->gte($expected);` : Assert that `$myInt` is greater than or equal to `$expected`\r\n* `$assert->int($myInt)->lte($expected);` : Assert that `$myInt` is less than or equal to `$expected`\r\n\r\nAll of the above may be modified with a call to `not()` before the assertion to negate the meaning of the assertion.  For example:\r\n\r\n```\r\n $assert->int($myInt)->not()->eq($expected);\r\n```\r\n\r\n*Note*: This library only allows assertions to compare identical numeric types.  `$assert->int(1)->eq(1.0);` produces a type error.\r\n\r\n### String Assertions\r\n\r\nTo make assertions about `string` type variables, call `$assert->string($myString)`.  The resulting object contains the following methods to actually perform the appropriate assertion.\r\n\r\n* `$assert->string($myString)->is($expected)` : Assert that `$myString === $expected`\r\n* `$assert->string($myString)->hasLength($int)` : Assert that the string has a length of `$int`\r\n* `$assert->string($myString)->matches($pattern)` : Assert that the regular expression contained in `$pattern` matches the string\r\n* `$assert->string($myString)->contains($subString)` : Assert that `$subString` is a substring of `$myString`\r\n* `$assert->string($myString)->containedBy($superString)` : Assert that `$myString` is a substring of `$superString`\r\n\r\nAll of the above assertions may be negated by calling `not()` before making the assertion.  For example:\r\n\r\n```\r\n $assert->string($myString)->not()->containedBy($superString);\r\n```\r\n\r\n### Collection Assertions\r\n\r\nTo make assertions about collections and arrays, call `$assert->container($context)`.  The resulting object contains the following methods to perform assertions.\r\n\r\n* `$assert->container($context)->isEmpty();` : Assert that the context has no elements\r\n* `$assert->container($context)->contains($value);` : Assert that the context contains the value given\r\n* `$assert->container($context)->containsAny($list);` : Assert that the context contains at least one element in the list provided\r\n* `$assert->container($context)->containsAll($list);` : Assert that the context contains all elements in the list provided\r\n* `$assert->container($context)->containsOnly($list);` : Assert that the context contains all elements in the list provided and no more\r\n\r\nAll of the `contains*` assertions above accept an optional second parameter which must be a callable.  The callable will be used to compare the elements in the context with the element(s) provided. If the elements passed to the callable should be treated as equivalent, the callable should return `true`, otherwise it should return `false`.\r\n\r\n#### Keyed Collections\r\n\r\nIf the keys of the container are important for the assertions, you should use `$assert->keyedContainer($context)`.  The resulting object contains the following methods to perform assertions.\r\n\r\n* `$assert->container($context)->contains($key, $value);` : Assert that the value contained in the context at the key provided matches the value provided\r\n* `$assert->container($context)->containsKey($key);` : Assert that the context contains the provided key\r\n* `$assert->container($context)->containsAny($list);` : Assert that the context contains at least one element in the list provided where both the key and value must be considered equivalent\r\n* `$assert->container($context)->containsAll($list);` : Assert that the context contains all elements in the list provided where both the key and value must be considered equivalent\r\n* `$assert->container($context)->containsOnly($list);` : Assert that the context contains all elements in the list provided and no more where both the key and value must be considered equivalent\r\n\r\nAll of the assertions above accept an optional second (or third in the case of `contains`) parameter which must be a callable.  The callable will be used to compare the values of the elements in the context with the element(s) provided. If the values passed to the callable should be treated as equivalent, the callable should return `true`, otherwise it should return `false`.\r\n\r\n### Mixed Assertions\r\n\r\nTo make generic assertions about a variable of any type, call `$assert->mixed($context)`.  The resulting object contains the following methods to actually perform the appropriate assertion.\r\n\r\n* `$assert->mixed($context)->isNull();` : Assert that `$context === null`\r\n* `$assert->mixed($context)->isBool();` : Assert that `$context` is of type `bool`\r\n* `$assert->mixed($context)->isInt();` : Assert that `$context` is of type `int`\r\n* `$assert->mixed($context)->isFloat();` : Assert that `$context` is of type `float`\r\n* `$assert->mixed($context)->isString();` : Assert that `$context` is of type `string`\r\n* `$assert->mixed($context)->isArray();` : Assert that `$context` is of type `array`\r\n* `$assert->mixed($context)->isObject();` : Assert that `$context` is of type `object`\r\n* `$assert->mixed($context)->isTypeOf($className)` : Assert that `$context instanceof $className`\r\n* `$assert->mixed($context)->looselyEquals($expected)` : Assert that `$context == $expected` *note the loose comparison*\r\n* `$assert->mixed($context)->identicalTo($expected)` : Assert that `$context === $expected` *note the strict comparison*\r\n\r\nSkipping Tests\r\n-------------\r\nThere are two ways to skip execution of a particular test method:\r\n\r\n1. Add the attribute `<<Skip>>` to the test method or the test suite.  If the `<<Skip>>` attribute is added to the suite, all tests in that class will be skipped.\r\n1. Invoke the `skip()` method of the `Assert` object passed to your test method.\r\n\r\n```php\r\nuse \\HackPack\\HackUnit\\Contract\\Assert;\r\n\r\n<<Skip>>\r\nclass SkippedSuite\r\n{\r\n    // All methods here would be skipped\r\n}\r\n\r\nclass MySuite\r\n{\r\n    <<Test, Skip>>\r\n    public function skippedTest(Assertion $assert) : void\r\n    {\r\n        // This will not be run and the test will be marked skip in the report.\r\n    }\r\n\r\n    <<Test>>\r\n    public function skipFromMiddleOfTest(Assert $assert) : void\r\n    {\r\n        // This will be run\r\n        $assert->skip();\r\n        // This will not be run and the test will be marked skip in the report.\r\n    }\r\n}\r\n```\r\n\r\nHow HackUnit loads tests\r\n------------------------\r\nAll files inside the base path(s) specified from the command line will be scanned for class definitions using Fred Emmott's\r\n[Definition Finder](https://github.com/fredemmott/definition-finder) library. Those files will then be loaded and reflection is used to determine\r\nwhich classes are test suites, and which methods perform each task in the suite.\r\n\r\nThanks [Fred!](https://github.com/fredemmott)\r\n\r\nStrict mode all the files!\r\n-----------------------------\r\n\r\nWell... not quite.\r\n\r\nTop level code must use `// partial` mode, so the `bin/hackunit` file is not in strict mode.  The rest of the project is, with one exception.\r\nTest suite files must be dynamically loaded after being scanned for test suites.  The only way I can see to perform this dynamic inclusion is to use `include_once` inside\r\nof a class method, which is disallowed in strict mode.  This one exception is marked with a `/* HH_FIXME */` comment, which disables the type checker for that\r\none line.\r\n\r\nRunning HackUnit's tests\r\n------------------------\r\nHackUnit is tested with HackUnit. From the project directory run:\r\n\r\n```\r\nhhvm /path/to/composer.phar test\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}